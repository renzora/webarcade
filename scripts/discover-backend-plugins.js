const fs = require('fs');
const path = require('path');

/**
 * Automatically discover backend plugins from bridge/src/plugins directory
 * and generate bridge/src/plugins/generated.rs
 */

const PLUGINS_DIR = path.join(__dirname, '../src/plugins');
const OUTPUT_FILE = path.join(__dirname, '../src-tauri/src/bridge/plugins/generated.rs');

function toPascalCase(str) {
  return str.split('_').map(word =>
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join('');
}

function scanPluginsDirectory() {
  const plugins = [];

  if (!fs.existsSync(PLUGINS_DIR)) {
    return plugins;
  }

  const items = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true });

  for (const item of items) {
    if (!item.isDirectory()) continue;

    const pluginName = item.name;
    const pluginPath = path.join(PLUGINS_DIR, pluginName);
    const modPath = path.join(pluginPath, 'mod.rs');

    // Check if this plugin has a mod.rs file
    if (fs.existsSync(modPath)) {
      // Validate Rust identifier
      if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(pluginName)) {
        plugins.push(pluginName);
      } else {
        console.warn(`‚ö†Ô∏è  Skipping '${pluginName}' - invalid Rust module name`);
      }
    }
  }

  return plugins.sort();
}

function generatePluginsCode() {
  console.log('üîç Scanning bridge plugins...');

  const plugins = scanPluginsDirectory();

  // Generate module declarations with path attributes
  let code = '// Auto-generated by scripts/discover-backend-plugins.js\n';
  code += '// DO NOT EDIT MANUALLY\n\n';

  for (const plugin of plugins) {
    code += `#[path = "../../../../src/plugins/${plugin}/mod.rs"]\n`;
    code += `pub mod ${plugin};\n`;
  }

  code += '\n';

  // Generate registration function
  code += 'use crate::bridge::core::plugin_manager::PluginManager;\n\n';
  code += '/// Auto-generated plugin registration function\n';
  code += 'pub fn register_all_plugins(manager: &mut PluginManager) {\n';
  code += `    log::info!("üì¶ Registering ${plugins.length} auto-discovered plugins...");\n\n`;

  // Group plugins
  const corePlugins = plugins.filter(p => p === 'database');
  const foundationalPlugins = plugins.filter(p => ['currency', 'notes', 'goals', 'todos', 'counters'].includes(p));
  const gamePlugins = plugins.filter(p => ['auction', 'roulette', 'levels', 'wheel', 'packs'].includes(p));
  const otherPlugins = plugins.filter(p =>
    !corePlugins.includes(p) &&
    !foundationalPlugins.includes(p) &&
    !gamePlugins.includes(p)
  );

  if (corePlugins.length > 0) {
    code += '    // Tier 0: Core plugins\n';
    for (const plugin of corePlugins) {
      const structName = toPascalCase(plugin);
      code += `    manager.register(${plugin}::${structName}Plugin);\n`;
    }
    code += '\n';
  }

  if (foundationalPlugins.length > 0) {
    code += '    // Tier 1: Foundational plugins\n';
    for (const plugin of foundationalPlugins) {
      const structName = toPascalCase(plugin);
      code += `    manager.register(${plugin}::${structName}Plugin);\n`;
    }
    code += '\n';
  }

  if (gamePlugins.length > 0) {
    code += '    // Tier 2: Game plugins\n';
    for (const plugin of gamePlugins) {
      const structName = toPascalCase(plugin);
      code += `    manager.register(${plugin}::${structName}Plugin);\n`;
    }
    code += '\n';
  }

  if (otherPlugins.length > 0) {
    code += '    // Tier 3+: Other plugins\n';
    for (const plugin of otherPlugins) {
      const structName = toPascalCase(plugin);
      code += `    manager.register(${plugin}::${structName}Plugin);\n`;
    }
    code += '\n';
  }

  code += `    log::info!("‚úÖ Plugin registration complete (${plugins.length} plugins)");\n`;
  code += '}\n';

  // Write the generated code
  fs.writeFileSync(OUTPUT_FILE, code, 'utf-8');

  console.log(`‚úÖ Generated src-tauri/src/bridge/plugins/generated.rs with ${plugins.length} plugins`);
  plugins.forEach(plugin => {
    console.log(`   - ${plugin}`);
  });

  return plugins;
}

// Run the generator
try {
  generatePluginsCode();
} catch (error) {
  console.error('‚ùå Error generating backend plugins:', error);
  process.exit(1);
}
